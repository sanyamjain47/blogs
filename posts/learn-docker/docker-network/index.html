<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Docker Networks | Sanyam's Blog</title>
<meta name=keywords content="Docker,DockerNetwork"><meta name=description content="Different types of Networks in Docker"><meta name=author content="Sanyam Jain"><link rel=canonical href=https://sanyamjain47.github.io/blogs/posts/learn-docker/docker-network/><link crossorigin=anonymous href=/blogs/assets/css/stylesheet.e087fd1dc76e73a35ae6d7028ddc1ba41e0131e7f9b3a6e2d019a208e6d6c4b5.css integrity="sha256-4If9Hcduc6Na5tcCjdwbpB4BMef5s6bi0BmiCObWxLU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blogs/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://sanyamjain47.github.io/blogs/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sanyamjain47.github.io/blogs/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sanyamjain47.github.io/blogs/favicon-32x32.png><link rel=apple-touch-icon href=https://sanyamjain47.github.io/blogs/apple-touch-icon.png><link rel=mask-icon href=https://sanyamjain47.github.io/blogs/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Docker Networks"><meta property="og:description" content="Different types of Networks in Docker"><meta property="og:type" content="article"><meta property="og:url" content="https://sanyamjain47.github.io/blogs/posts/learn-docker/docker-network/"><meta property="og:image" content="https://sanyamjain47.github.io/blogs/images/blog-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-26T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-26T00:00:00+00:00"><meta property="og:see_also" content="https://sanyamjain47.github.io/blogs/posts/learn-docker/basic-commands/"><meta property="og:see_also" content="https://sanyamjain47.github.io/blogs/posts/learn-docker/docker-compose/"><meta property="og:see_also" content="https://sanyamjain47.github.io/blogs/posts/learn-docker/introduction/"><meta property="og:see_also" content="https://sanyamjain47.github.io/blogs/posts/learn-docker/docker-file/"><meta property="og:see_also" content="https://sanyamjain47.github.io/blogs/posts/learn-docker/volumes-in-docker/"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sanyamjain47.github.io/blogs/images/blog-cover.png"><meta name=twitter:title content="Docker Networks"><meta name=twitter:description content="Different types of Networks in Docker"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sanyamjain47.github.io/blogs/posts/"},{"@type":"ListItem","position":2,"name":"Learning Docker","item":"https://sanyamjain47.github.io/blogs/posts/learn-docker/"},{"@type":"ListItem","position":3,"name":"Docker Networks","item":"https://sanyamjain47.github.io/blogs/posts/learn-docker/docker-network/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Docker Networks","name":"Docker Networks","description":"Different types of Networks in Docker","keywords":["Docker","DockerNetwork"],"articleBody":"Types of Networks in Docker The default bridge network Docker installs a virtual bridge, docker0, on the host machine during installation. This bridge acts as a virtual switch to which virtual network interfaces (veths) of containers are connected. Each container gets its own IP address in the Docker host’s private network range. When a container is created, Docker also creates a pair of virtual Ethernet (vEth) interfaces. One end of this pair is attached to the container, acting as its network interface. The other end is attached to the Docker bridge, allowing the container to communicate with the bridge and through it, with other containers or external networks. By default, containers are isolated from the outside world. To allow external access to services running in a container, specific ports must be exposed. This is done using the -p or --publish flag in the docker run command, which maps a port on the host to a port in the container. Docker manipulates iptables rules to forward traffic from the exposed host port to the corresponding container port. Containers connected to the default bridge network can communicate with each other using their internal IP addresses. This is possible because they are all connected to the docker0 bridge. The default bridge network is not recommended for complex applications as it lacks advanced features like automatic DNS resolution for container names. User-defined bridge networks User-defined bridges are created using the docker network create command. This command allows for additional configurations and customizations.\nThey are managed independently of the default bridge, offering more flexibility and control.\nOne of the significant advantages of user-defined bridges is automatic DNS resolution. Containers on the same user-defined bridge network can communicate with each other by their container names, which the network’s internal DNS server resolves.\nUser-defined bridges provide better network isolation compared to the default bridge. Each user-defined bridge network operates independently, creating a separate network environment for the containers connected to it.\nContainers attached to the same user-defined bridge network can talk to each other directly. By default, inter-container communication is enabled, but it can be disabled when creating the network for added security.\nContainers can be connected to a user-defined bridge network using the --network option when they are run or created.\nSimilar to the default bridge, ports can be exposed and mapped to the host in user-defined bridge networks using the -p or --publish option.\nUser-defined bridges allow for additional network configurations like specifying the subnet, the IP address range, the gateway, and even the IP address of individual containers.\nUser-defined bridge networks can offer improved performance in terms of network communication between containers compared to the default bridge network.\nThey are particularly useful in scenarios where multiple containers need to communicate on the same Docker host, but isolation from other containers or networks is also required.\nIdeal for development and testing environments where you need a quick and easy way to segment network traffic.\nThe Host network Containers using the host network type bypass Docker’s networking stack entirely. They share the network namespace with the Docker host, meaning they use the host’s IP address and have access to its network ports directly. This setup can offer improved network performance since it removes the network isolation between the container and the Docker host, reducing the overhead associated with network virtualization. In host networking mode, port mapping is not required for containers to communicate with the outside world, as they are using the host’s network directly. Containers can open any port directly on the host’s network interface. Since containers share the host’s network namespace, they also use the host’s DNS settings and routing tables. This simplifies scenarios where specific network configurations on the host need to be reused by the containers. The lack of network isolation in host mode can be a security concern. Containers have the same network privileges as processes running directly on the host. This setup is generally not recommended for multi-tenant environments or where container isolation is a priority. Host networking is often used in situations where high network throughput is required and security or network isolation is not a major concern. It’s commonly used for network debugging purposes or for running services that need to manage the host’s network stack directly. Containers in host network mode cannot be connected to other Docker networks. They only have access to the host’s network. Unlike bridge networks, host networking provides no network isolation, no automatic DNS resolution for other containers, and does not use internal Docker IP addresses. The MACVLAN network The macvlan network type in Docker is designed to enable containers to appear as physical devices on your network. This setup is particularly useful in scenarios where you need containers to have full network stack independence from the host.\nMacvlan networks allow containers to have their own MAC address and IP address on the physical network, making them appear as physical network devices to other devices on the same LAN.\nThis approach bypasses the need for port mapping, as each container can be directly addressed on the network.\nA macvlan network is created as a Docker network type.\nEach container connected to a macvlan network gets its own unique MAC address.\nThe Docker host’s network interface is used as the parent interface for the macvlan network.\nContainers on a macvlan network are isolated at Layer 2 (Data Link Layer), providing a high degree of network isolation and security.\nIt’s particularly useful in enterprise environments where containers need to be integrated into existing VLANs or need to be compliant with network policies that require devices to have their own MAC/IP.\nIdeal for running legacy applications that expect to be on a physical network.\nA subinterface in macvlan is essentially a subdivision of a physical network interface.\nIt allows for the creation of multiple distinct logical interfaces, each with its own MAC and IP address, on a single physical interface.\nThis setup can be used to create different macvlan networks segregated at Layer 2, which can be useful for creating VLAN-like behavior within Docker.\nMacvlan provides strong network separation and can offer better performance for certain network-intensive applications.\nHowever, it requires careful planning in terms of network security and management, as each container is effectively a network endpoint.\nMacvlan does not allow for container-to-host network communication using the macvlan interface. This is a key difference from other network types.\nIt requires a compatible physical network environment and may not be suitable for all deployments, particularly where network hardware or policies do not support this kind of configuration.\nThe IPVLAN network The ipvlan network type in Docker provides a way to assign multiple IP addresses to a single network interface, allowing containers to share a common physical network interface while maintaining separate network identities. This approach is similar to macvlan but with some key differences. Here’s an overview of ipvlan and its modes:\nIPVLAN Network Overview: Designed to give containers their own IP addresses and to allow them to appear as unique devices on the network, similar to macvlan. Useful in environments where macvlan might not be suitable due to MAC address limitations. Containers share the host’s physical network interface but have independent IP addresses. This design makes ipvlan more efficient in environments where MAC address limitation is a concern. Layer 2 (L2) Mode:\nIn L2 mode, ipvlan acts similarly to a traditional Ethernet network. Containers are assigned their own IP addresses but share the MAC address of the host’s network interface. Containers can communicate with each other and with external devices on the same LAN. Good for environments where layer 3 (routing) capabilities are not necessary or desired. Layer 3 (L3) Mode:\nIn L3 mode, ipvlan operates at the network layer. Each container gets its own IP address, and the network traffic is routed. Containers are not able to communicate with each other at layer 2; instead, all inter-container communication is routed. Ideal for situations where network segmentation and routing are more important than broadcast or multicast traffic. Key Features: Ipvlan is more efficient in terms of the number of MAC addresses used, making it suitable for large-scale deployments.\nWorks with existing network infrastructures that support VLANs and traditional routing.\nProvides network isolation at either the data link layer (L2) or network layer (L3), depending on the mode used.\nUseful in environments with a large number of containers where MAC address exhaustion could be an issue.\nSuitable for scenarios requiring advanced network segmentation and policy enforcement.\nSimilar to macvlan, ipvlan in both modes does not allow containers to communicate with the host over the ipvlan interface.\nRequires a good understanding of network fundamentals to deploy effectively.\nNotes I know this has been a lot of notes but this is to keep a track of what I have learned. I will be using this as a reference for future projects. I will also be adding more notes as I learn more about docker. Below is a comparison of similar network types.\n1. Macvlan vs. Ipvlan: MAC Address Handling:\nMacvlan: Assigns a unique MAC address to each container, making each container appear as a separate physical device on the network. Ipvlan: Containers share the MAC address of the host’s network interface. This approach reduces the number of MAC addresses used in the network. Network Layer Operation:\nMacvlan: Operates at Layer 2 (Data Link Layer), allowing containers to communicate like physical devices connected to the same LAN. Ipvlan: Can operate either at Layer 2 (L2 mode) like Macvlan or at Layer 3 (L3 mode), focusing on network segmentation and routing. Host Communication:\nBoth Macvlan and Ipvlan: Containers cannot communicate with the host over the same interface. Use Case:\nMacvlan: Suitable for environments where containers need to be treated as distinct physical devices, often used in enterprise settings. Ipvlan: Preferred in large-scale deployments to avoid MAC address exhaustion and when network layer segmentation is crucial. 2. Macvlan/Ipvlan vs. Bridge: Network Isolation:\nMacvlan/Ipvlan: Containers are isolated at the network level, appearing as unique network entities. Bridge: Containers on the same bridge network can communicate with each other but are isolated from the host network. IP and MAC Address:\nMacvlan/Ipvlan: Containers have their own IP and (in Macvlan) MAC addresses, separate from the host. Bridge: Containers use internal Docker IP addresses; the host manages network traffic through NAT and port mapping. Performance:\nMacvlan/Ipvlan: Potentially higher network performance due to direct access to the physical network. Bridge: Slightly lower performance due to NAT overhead. Ease of Use:\nMacvlan/Ipvlan: Requires more network knowledge and careful planning. Bridge: Easier to set up and use, especially for those new to Docker networking. Port Mapping:\nMacvlan/Ipvlan: No need for port mapping, as each container can directly expose ports. Bridge: Requires port mapping to expose container services to the external network. Summary: Macvlan is ideal for environments where containers need to appear as physical devices on the network. Ipvlan is a more efficient alternative to Macvlan, especially in large-scale deployments or when layer 3 routing is needed. Bridge networks are the simplest to use, suitable for most standard Docker deployments where complex networking is not a requirement. ","wordCount":"1849","inLanguage":"en","datePublished":"2023-12-26T00:00:00Z","dateModified":"2023-12-26T00:00:00Z","author":[{"@type":"Person","name":"Sanyam Jain"}],"mainEntityOfPage":{"@type":"WebPage","@id":"https://sanyamjain47.github.io/blogs/posts/learn-docker/docker-network/"},"publisher":{"@type":"Organization","name":"Sanyam's Blog","logo":{"@type":"ImageObject","url":"https://sanyamjain47.github.io/blogs/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sanyamjain47.github.io/blogs/ accesskey=h title="Sanyam's Blog (Alt + H)">Sanyam's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sanyamjain47.github.io/blogs/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://sanyamjain47.github.io/blogs/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://sanyamjain47.github.io/blogs/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://sanyamjain47.github.io/blogs/series/ title=Series><span>Series</span></a></li><li><a href=https://sanyamjain47.github.io/blogs/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sanyamjain47.github.io/blogs/>Home</a>&nbsp;»&nbsp;<a href=https://sanyamjain47.github.io/blogs/posts/>Posts</a>&nbsp;»&nbsp;<a href=https://sanyamjain47.github.io/blogs/posts/learn-docker/>Learning Docker</a></div><h1 class="post-title entry-hint-parent">Docker Networks</h1><div class=post-meta><span title='2023-12-26 00:00:00 +0000 UTC'>December 26, 2023</span>&nbsp;·&nbsp;9 min&nbsp;·&nbsp;Sanyam Jain</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#types-of-networks-in-docker aria-label="Types of Networks in Docker">Types of Networks in Docker</a><ul><li><a href=#the-default-bridge-network aria-label="The default bridge network">The default bridge network</a></li><li><a href=#user-defined-bridge-networks aria-label="User-defined bridge networks">User-defined bridge networks</a></li><li><a href=#the-host-network aria-label="The Host network">The Host network</a></li><li><a href=#the-macvlan-network aria-label="The MACVLAN network">The MACVLAN network</a></li><li><a href=#the-ipvlan-network aria-label="The IPVLAN network">The IPVLAN network</a><ul><li><a href=#ipvlan-network-overview aria-label="IPVLAN Network Overview:">IPVLAN Network Overview:</a><ul><li><a href=#key-features aria-label="Key Features:">Key Features:</a></li></ul></li></ul></li></ul></li><li><a href=#notes aria-label=Notes>Notes</a><ul><ul><li><a href=#1-macvlan-vs-ipvlan aria-label="1. Macvlan vs. Ipvlan:">1. Macvlan vs. Ipvlan:</a></li><li><a href=#2-macvlanipvlan-vs-bridge aria-label="2. Macvlan/Ipvlan vs. Bridge:">2. Macvlan/Ipvlan vs. Bridge:</a></li><li><a href=#summary aria-label=Summary:>Summary:</a></li></ul></ul></li></ul></div></details></div><div class=post-content><h1 id=types-of-networks-in-docker>Types of Networks in Docker<a hidden class=anchor aria-hidden=true href=#types-of-networks-in-docker>#</a></h1><h2 id=the-default-bridge-network>The default bridge network<a hidden class=anchor aria-hidden=true href=#the-default-bridge-network>#</a></h2><ul><li>Docker installs a virtual bridge, <code>docker0</code>, on the host machine during installation.</li><li>This bridge acts as a virtual switch to which virtual network interfaces (veths) of containers are connected.</li><li>Each container gets its own IP address in the Docker host&rsquo;s private network range.</li><li>When a container is created, Docker also creates a pair of virtual Ethernet (vEth) interfaces.</li><li>One end of this pair is attached to the container, acting as its network interface.</li><li>The other end is attached to the Docker bridge, allowing the container to communicate with the bridge and through it, with other containers or external networks.</li><li>By default, containers are isolated from the outside world.</li><li>To allow external access to services running in a container, specific ports must be exposed.</li><li>This is done using the <code>-p</code> or <code>--publish</code> flag in the <code>docker run</code> command, which maps a port on the host to a port in the container.</li><li>Docker manipulates <code>iptables</code> rules to forward traffic from the exposed host port to the corresponding container port.</li><li>Containers connected to the default bridge network can communicate with each other using their internal IP addresses.</li><li>This is possible because they are all connected to the <code>docker0</code> bridge.</li><li>The default bridge network is not recommended for complex applications as it lacks advanced features like automatic DNS resolution for container names.</li></ul><h2 id=user-defined-bridge-networks>User-defined bridge networks<a hidden class=anchor aria-hidden=true href=#user-defined-bridge-networks>#</a></h2><ul><li><p>User-defined bridges are created using the <code>docker network create</code> command. This command allows for additional configurations and customizations.</p></li><li><p>They are managed independently of the default bridge, offering more flexibility and control.</p></li><li><p>One of the significant advantages of user-defined bridges is automatic DNS resolution. Containers on the same user-defined bridge network can communicate with each other by their container names, which the network&rsquo;s internal DNS server resolves.</p></li><li><p>User-defined bridges provide better network isolation compared to the default bridge. Each user-defined bridge network operates independently, creating a separate network environment for the containers connected to it.</p></li><li><p>Containers attached to the same user-defined bridge network can talk to each other directly. By default, inter-container communication is enabled, but it can be disabled when creating the network for added security.</p></li><li><p>Containers can be connected to a user-defined bridge network using the <code>--network</code> option when they are run or created.</p></li><li><p>Similar to the default bridge, ports can be exposed and mapped to the host in user-defined bridge networks using the <code>-p</code> or <code>--publish</code> option.</p></li><li><p>User-defined bridges allow for additional network configurations like specifying the subnet, the IP address range, the gateway, and even the IP address of individual containers.</p></li><li><p>User-defined bridge networks can offer improved performance in terms of network communication between containers compared to the default bridge network.</p></li><li><p>They are particularly useful in scenarios where multiple containers need to communicate on the same Docker host, but isolation from other containers or networks is also required.</p></li><li><p>Ideal for development and testing environments where you need a quick and easy way to segment network traffic.</p></li></ul><h2 id=the-host-network>The Host network<a hidden class=anchor aria-hidden=true href=#the-host-network>#</a></h2><ul><li>Containers using the host network type bypass Docker&rsquo;s networking stack entirely.</li><li>They share the network namespace with the Docker host, meaning they use the host&rsquo;s IP address and have access to its network ports directly.</li><li>This setup can offer improved network performance since it removes the network isolation between the container and the Docker host, reducing the overhead associated with network virtualization.</li><li>In host networking mode, port mapping is not required for containers to communicate with the outside world, as they are using the host&rsquo;s network directly.</li><li>Containers can open any port directly on the host&rsquo;s network interface.</li><li>Since containers share the host&rsquo;s network namespace, they also use the host&rsquo;s DNS settings and routing tables.</li><li>This simplifies scenarios where specific network configurations on the host need to be reused by the containers.</li><li>The lack of network isolation in host mode can be a security concern. Containers have the same network privileges as processes running directly on the host.</li><li>This setup is generally not recommended for multi-tenant environments or where container isolation is a priority.</li><li>Host networking is often used in situations where high network throughput is required and security or network isolation is not a major concern.</li><li>It&rsquo;s commonly used for network debugging purposes or for running services that need to manage the host’s network stack directly.</li><li>Containers in host network mode cannot be connected to other Docker networks. They only have access to the host&rsquo;s network.</li><li>Unlike bridge networks, host networking provides no network isolation, no automatic DNS resolution for other containers, and does not use internal Docker IP addresses.</li></ul><h2 id=the-macvlan-network>The MACVLAN network<a hidden class=anchor aria-hidden=true href=#the-macvlan-network>#</a></h2><p>The <code>macvlan</code> network type in Docker is designed to enable containers to appear as physical devices on your network. This setup is particularly useful in scenarios where you need containers to have full network stack independence from the host.</p><ul><li><p>Macvlan networks allow containers to have their own MAC address and IP address on the physical network, making them appear as physical network devices to other devices on the same LAN.</p></li><li><p>This approach bypasses the need for port mapping, as each container can be directly addressed on the network.</p></li><li><p>A macvlan network is created as a Docker network type.</p></li><li><p>Each container connected to a macvlan network gets its own unique MAC address.</p></li><li><p>The Docker host&rsquo;s network interface is used as the parent interface for the macvlan network.</p></li><li><p>Containers on a macvlan network are isolated at Layer 2 (Data Link Layer), providing a high degree of network isolation and security.</p></li><li><p>It&rsquo;s particularly useful in enterprise environments where containers need to be integrated into existing VLANs or need to be compliant with network policies that require devices to have their own MAC/IP.</p></li><li><p>Ideal for running legacy applications that expect to be on a physical network.</p></li><li><p>A subinterface in macvlan is essentially a subdivision of a physical network interface.</p></li><li><p>It allows for the creation of multiple distinct logical interfaces, each with its own MAC and IP address, on a single physical interface.</p></li><li><p>This setup can be used to create different macvlan networks segregated at Layer 2, which can be useful for creating VLAN-like behavior within Docker.</p></li><li><p>Macvlan provides strong network separation and can offer better performance for certain network-intensive applications.</p></li><li><p>However, it requires careful planning in terms of network security and management, as each container is effectively a network endpoint.</p></li><li><p>Macvlan does not allow for container-to-host network communication using the macvlan interface. This is a key difference from other network types.</p></li><li><p>It requires a compatible physical network environment and may not be suitable for all deployments, particularly where network hardware or policies do not support this kind of configuration.</p></li></ul><h2 id=the-ipvlan-network>The IPVLAN network<a hidden class=anchor aria-hidden=true href=#the-ipvlan-network>#</a></h2><p>The <code>ipvlan</code> network type in Docker provides a way to assign multiple IP addresses to a single network interface, allowing containers to share a common physical network interface while maintaining separate network identities. This approach is similar to <code>macvlan</code> but with some key differences. Here&rsquo;s an overview of <code>ipvlan</code> and its modes:</p><h3 id=ipvlan-network-overview>IPVLAN Network Overview:<a hidden class=anchor aria-hidden=true href=#ipvlan-network-overview>#</a></h3><ul><li>Designed to give containers their own IP addresses and to allow them to appear as unique devices on the network, similar to <code>macvlan</code>.</li><li>Useful in environments where <code>macvlan</code> might not be suitable due to MAC address limitations.</li><li>Containers share the host&rsquo;s physical network interface but have independent IP addresses.</li><li>This design makes <code>ipvlan</code> more efficient in environments where MAC address limitation is a concern.</li></ul><ol><li><p><strong>Layer 2 (L2) Mode:</strong></p><ul><li>In L2 mode, <code>ipvlan</code> acts similarly to a traditional Ethernet network.</li><li>Containers are assigned their own IP addresses but share the MAC address of the host&rsquo;s network interface.</li><li>Containers can communicate with each other and with external devices on the same LAN.</li><li>Good for environments where layer 3 (routing) capabilities are not necessary or desired.</li></ul></li><li><p><strong>Layer 3 (L3) Mode:</strong></p><ul><li>In L3 mode, <code>ipvlan</code> operates at the network layer.</li><li>Each container gets its own IP address, and the network traffic is routed.</li><li>Containers are not able to communicate with each other at layer 2; instead, all inter-container communication is routed.</li><li>Ideal for situations where network segmentation and routing are more important than broadcast or multicast traffic.</li></ul></li></ol><h4 id=key-features>Key Features:<a hidden class=anchor aria-hidden=true href=#key-features>#</a></h4><ul><li><p><code>Ipvlan</code> is more efficient in terms of the number of MAC addresses used, making it suitable for large-scale deployments.</p></li><li><p>Works with existing network infrastructures that support VLANs and traditional routing.</p></li><li><p>Provides network isolation at either the data link layer (L2) or network layer (L3), depending on the mode used.</p></li><li><p>Useful in environments with a large number of containers where MAC address exhaustion could be an issue.</p></li><li><p>Suitable for scenarios requiring advanced network segmentation and policy enforcement.</p></li><li><p>Similar to <code>macvlan</code>, <code>ipvlan</code> in both modes does not allow containers to communicate with the host over the <code>ipvlan</code> interface.</p></li><li><p>Requires a good understanding of network fundamentals to deploy effectively.</p></li></ul><h1 id=notes>Notes<a hidden class=anchor aria-hidden=true href=#notes>#</a></h1><blockquote><p>I know this has been a lot of notes but this is to keep a track of what I have learned. I will be using this as a reference for future projects. I will also be adding more notes as I learn more about docker.
Below is a comparison of similar network types.</p></blockquote><h3 id=1-macvlan-vs-ipvlan>1. Macvlan vs. Ipvlan:<a hidden class=anchor aria-hidden=true href=#1-macvlan-vs-ipvlan>#</a></h3><ul><li><p><strong>MAC Address Handling:</strong></p><ul><li><strong>Macvlan:</strong> Assigns a unique MAC address to each container, making each container appear as a separate physical device on the network.</li><li><strong>Ipvlan:</strong> Containers share the MAC address of the host&rsquo;s network interface. This approach reduces the number of MAC addresses used in the network.</li></ul></li><li><p><strong>Network Layer Operation:</strong></p><ul><li><strong>Macvlan:</strong> Operates at Layer 2 (Data Link Layer), allowing containers to communicate like physical devices connected to the same LAN.</li><li><strong>Ipvlan:</strong> Can operate either at Layer 2 (L2 mode) like Macvlan or at Layer 3 (L3 mode), focusing on network segmentation and routing.</li></ul></li><li><p><strong>Host Communication:</strong></p><ul><li><strong>Both Macvlan and Ipvlan:</strong> Containers cannot communicate with the host over the same interface.</li></ul></li><li><p><strong>Use Case:</strong></p><ul><li><strong>Macvlan:</strong> Suitable for environments where containers need to be treated as distinct physical devices, often used in enterprise settings.</li><li><strong>Ipvlan:</strong> Preferred in large-scale deployments to avoid MAC address exhaustion and when network layer segmentation is crucial.</li></ul></li></ul><h3 id=2-macvlanipvlan-vs-bridge>2. Macvlan/Ipvlan vs. Bridge:<a hidden class=anchor aria-hidden=true href=#2-macvlanipvlan-vs-bridge>#</a></h3><ul><li><p><strong>Network Isolation:</strong></p><ul><li><strong>Macvlan/Ipvlan:</strong> Containers are isolated at the network level, appearing as unique network entities.</li><li><strong>Bridge:</strong> Containers on the same bridge network can communicate with each other but are isolated from the host network.</li></ul></li><li><p><strong>IP and MAC Address:</strong></p><ul><li><strong>Macvlan/Ipvlan:</strong> Containers have their own IP and (in Macvlan) MAC addresses, separate from the host.</li><li><strong>Bridge:</strong> Containers use internal Docker IP addresses; the host manages network traffic through NAT and port mapping.</li></ul></li><li><p><strong>Performance:</strong></p><ul><li><strong>Macvlan/Ipvlan:</strong> Potentially higher network performance due to direct access to the physical network.</li><li><strong>Bridge:</strong> Slightly lower performance due to NAT overhead.</li></ul></li><li><p><strong>Ease of Use:</strong></p><ul><li><strong>Macvlan/Ipvlan:</strong> Requires more network knowledge and careful planning.</li><li><strong>Bridge:</strong> Easier to set up and use, especially for those new to Docker networking.</li></ul></li><li><p><strong>Port Mapping:</strong></p><ul><li><strong>Macvlan/Ipvlan:</strong> No need for port mapping, as each container can directly expose ports.</li><li><strong>Bridge:</strong> Requires port mapping to expose container services to the external network.</li></ul></li></ul><h3 id=summary>Summary:<a hidden class=anchor aria-hidden=true href=#summary>#</a></h3><ul><li><strong>Macvlan</strong> is ideal for environments where containers need to appear as physical devices on the network.</li><li><strong>Ipvlan</strong> is a more efficient alternative to Macvlan, especially in large-scale deployments or when layer 3 routing is needed.</li><li><strong>Bridge</strong> networks are the simplest to use, suitable for most standard Docker deployments where complex networking is not a requirement.</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://sanyamjain47.github.io/blogs/tags/docker/>Docker</a></li><li><a href=https://sanyamjain47.github.io/blogs/tags/dockernetwork/>DockerNetwork</a></li></ul><nav class=paginav><a class=prev href=https://sanyamjain47.github.io/blogs/posts/learn-docker/introduction/><span class=title>« Prev</span><br><span>Docker Intro</span>
</a><a class=next href=https://sanyamjain47.github.io/blogs/posts/learn-docker/docker-file/><span class=title>Next »</span><br><span>Dockerfiles</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networks on x" href="https://x.com/intent/tweet/?text=Docker%20Networks&amp;url=https%3a%2f%2fsanyamjain47.github.io%2fblogs%2fposts%2flearn-docker%2fdocker-network%2f&amp;hashtags=Docker%2cDockerNetwork"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networks on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsanyamjain47.github.io%2fblogs%2fposts%2flearn-docker%2fdocker-network%2f&amp;title=Docker%20Networks&amp;summary=Docker%20Networks&amp;source=https%3a%2f%2fsanyamjain47.github.io%2fblogs%2fposts%2flearn-docker%2fdocker-network%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networks on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsanyamjain47.github.io%2fblogs%2fposts%2flearn-docker%2fdocker-network%2f&title=Docker%20Networks"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networks on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsanyamjain47.github.io%2fblogs%2fposts%2flearn-docker%2fdocker-network%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networks on whatsapp" href="https://api.whatsapp.com/send?text=Docker%20Networks%20-%20https%3a%2f%2fsanyamjain47.github.io%2fblogs%2fposts%2flearn-docker%2fdocker-network%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networks on telegram" href="https://telegram.me/share/url?text=Docker%20Networks&amp;url=https%3a%2f%2fsanyamjain47.github.io%2fblogs%2fposts%2flearn-docker%2fdocker-network%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Docker Networks on ycombinator" href="https://news.ycombinator.com/submitlink?t=Docker%20Networks&u=https%3a%2f%2fsanyamjain47.github.io%2fblogs%2fposts%2flearn-docker%2fdocker-network%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://sanyamjain47.github.io/blogs/>Sanyam's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>